"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ra-data-simple-rest";
exports.ids = ["vendor-chunks/ra-data-simple-rest"];
exports.modules = {

/***/ "(ssr)/./node_modules/ra-data-simple-rest/dist/esm/index.js":
/*!************************************************************!*\
  !*** ./node_modules/ra-data-simple-rest/dist/esm/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var query_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! query-string */ \"(ssr)/./node_modules/query-string/index.js\");\n/* harmony import */ var ra_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ra-core */ \"(ssr)/./node_modules/ra-core/dist/esm/dataProvider/fetch.js\");\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n\n/**\n * Maps react-admin queries to a simple REST API\n *\n * This REST dialect is similar to the one of FakeRest\n *\n * @see https://github.com/marmelab/FakeRest\n *\n * @example\n *\n * getList     => GET http://my.api.url/posts?sort=['title','ASC']&range=[0, 24]\n * getOne      => GET http://my.api.url/posts/123\n * getMany     => GET http://my.api.url/posts?filter={id:[123,456,789]}\n * update      => PUT http://my.api.url/posts/123\n * create      => POST http://my.api.url/posts\n * delete      => DELETE http://my.api.url/posts/123\n *\n * @example\n *\n * import * as React from \"react\";\n * import { Admin, Resource } from 'react-admin';\n * import simpleRestProvider from 'ra-data-simple-rest';\n *\n * import { PostList } from './posts';\n *\n * const App = () => (\n *     <Admin dataProvider={simpleRestProvider('http://path.to.my.api/')}>\n *         <Resource name=\"posts\" list={PostList} />\n *     </Admin>\n * );\n *\n * export default App;\n */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function (apiUrl, httpClient, countHeader) {\n    if (httpClient === void 0) { httpClient = ra_core__WEBPACK_IMPORTED_MODULE_1__.fetchJson; }\n    if (countHeader === void 0) { countHeader = 'Content-Range'; }\n    return ({\n        getList: function (resource, params) {\n            var _a = params.pagination, page = _a.page, perPage = _a.perPage;\n            var _b = params.sort, field = _b.field, order = _b.order;\n            var rangeStart = (page - 1) * perPage;\n            var rangeEnd = page * perPage - 1;\n            var query = {\n                sort: JSON.stringify([field, order]),\n                range: JSON.stringify([rangeStart, rangeEnd]),\n                filter: JSON.stringify(params.filter),\n            };\n            var url = \"\".concat(apiUrl, \"/\").concat(resource, \"?\").concat((0,query_string__WEBPACK_IMPORTED_MODULE_0__.stringify)(query));\n            var options = countHeader === 'Content-Range'\n                ? {\n                    // Chrome doesn't return `Content-Range` header if no `Range` is provided in the request.\n                    headers: new Headers({\n                        Range: \"\".concat(resource, \"=\").concat(rangeStart, \"-\").concat(rangeEnd),\n                    }),\n                }\n                : {};\n            return httpClient(url, options).then(function (_a) {\n                var headers = _a.headers, json = _a.json;\n                if (!headers.has(countHeader)) {\n                    throw new Error(\"The \".concat(countHeader, \" header is missing in the HTTP Response. The simple REST data provider expects responses for lists of resources to contain this header with the total number of results to build the pagination. If you are using CORS, did you declare \").concat(countHeader, \" in the Access-Control-Expose-Headers header?\"));\n                }\n                return {\n                    data: json,\n                    total: countHeader === 'Content-Range'\n                        ? parseInt(headers.get('content-range').split('/').pop(), 10)\n                        : parseInt(headers.get(countHeader.toLowerCase())),\n                };\n            });\n        },\n        getOne: function (resource, params) {\n            return httpClient(\"\".concat(apiUrl, \"/\").concat(resource, \"/\").concat(params.id)).then(function (_a) {\n                var json = _a.json;\n                return ({\n                    data: json,\n                });\n            });\n        },\n        getMany: function (resource, params) {\n            var query = {\n                filter: JSON.stringify({ id: params.ids }),\n            };\n            var url = \"\".concat(apiUrl, \"/\").concat(resource, \"?\").concat((0,query_string__WEBPACK_IMPORTED_MODULE_0__.stringify)(query));\n            return httpClient(url).then(function (_a) {\n                var json = _a.json;\n                return ({ data: json });\n            });\n        },\n        getManyReference: function (resource, params) {\n            var _a;\n            var _b = params.pagination, page = _b.page, perPage = _b.perPage;\n            var _c = params.sort, field = _c.field, order = _c.order;\n            var rangeStart = (page - 1) * perPage;\n            var rangeEnd = page * perPage - 1;\n            var query = {\n                sort: JSON.stringify([field, order]),\n                range: JSON.stringify([(page - 1) * perPage, page * perPage - 1]),\n                filter: JSON.stringify(__assign(__assign({}, params.filter), (_a = {}, _a[params.target] = params.id, _a))),\n            };\n            var url = \"\".concat(apiUrl, \"/\").concat(resource, \"?\").concat((0,query_string__WEBPACK_IMPORTED_MODULE_0__.stringify)(query));\n            var options = countHeader === 'Content-Range'\n                ? {\n                    // Chrome doesn't return `Content-Range` header if no `Range` is provided in the request.\n                    headers: new Headers({\n                        Range: \"\".concat(resource, \"=\").concat(rangeStart, \"-\").concat(rangeEnd),\n                    }),\n                }\n                : {};\n            return httpClient(url, options).then(function (_a) {\n                var headers = _a.headers, json = _a.json;\n                if (!headers.has(countHeader)) {\n                    throw new Error(\"The \".concat(countHeader, \" header is missing in the HTTP Response. The simple REST data provider expects responses for lists of resources to contain this header with the total number of results to build the pagination. If you are using CORS, did you declare \").concat(countHeader, \" in the Access-Control-Expose-Headers header?\"));\n                }\n                return {\n                    data: json,\n                    total: countHeader === 'Content-Range'\n                        ? parseInt(headers.get('content-range').split('/').pop(), 10)\n                        : parseInt(headers.get(countHeader.toLowerCase())),\n                };\n            });\n        },\n        update: function (resource, params) {\n            return httpClient(\"\".concat(apiUrl, \"/\").concat(resource, \"/\").concat(params.id), {\n                method: 'PUT',\n                body: JSON.stringify(params.data),\n            }).then(function (_a) {\n                var json = _a.json;\n                return ({ data: json });\n            });\n        },\n        // simple-rest doesn't handle provide an updateMany route, so we fallback to calling update n times instead\n        updateMany: function (resource, params) {\n            return Promise.all(params.ids.map(function (id) {\n                return httpClient(\"\".concat(apiUrl, \"/\").concat(resource, \"/\").concat(id), {\n                    method: 'PUT',\n                    body: JSON.stringify(params.data),\n                });\n            })).then(function (responses) { return ({ data: responses.map(function (_a) {\n                    var json = _a.json;\n                    return json.id;\n                }) }); });\n        },\n        create: function (resource, params) {\n            return httpClient(\"\".concat(apiUrl, \"/\").concat(resource), {\n                method: 'POST',\n                body: JSON.stringify(params.data),\n            }).then(function (_a) {\n                var json = _a.json;\n                return ({ data: json });\n            });\n        },\n        delete: function (resource, params) {\n            return httpClient(\"\".concat(apiUrl, \"/\").concat(resource, \"/\").concat(params.id), {\n                method: 'DELETE',\n                headers: new Headers({\n                    'Content-Type': 'text/plain',\n                }),\n            }).then(function (_a) {\n                var json = _a.json;\n                return ({ data: json });\n            });\n        },\n        // simple-rest doesn't handle filters on DELETE route, so we fallback to calling DELETE n times instead\n        deleteMany: function (resource, params) {\n            return Promise.all(params.ids.map(function (id) {\n                return httpClient(\"\".concat(apiUrl, \"/\").concat(resource, \"/\").concat(id), {\n                    method: 'DELETE',\n                    headers: new Headers({\n                        'Content-Type': 'text/plain',\n                    }),\n                });\n            })).then(function (responses) { return ({\n                data: responses.map(function (_a) {\n                    var json = _a.json;\n                    return json.id;\n                }),\n            }); });\n        },\n    });\n});\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmEtZGF0YS1zaW1wbGUtcmVzdC9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxnQkFBZ0IsU0FBSSxJQUFJLFNBQUk7QUFDNUI7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3lDO0FBQ0o7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBLDRCQUE0Qiw2Q0FBNkM7QUFDekUsd0NBQXdDLFVBQVU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFnQjtBQUNoQixpQ0FBaUMsYUFBYSw4Q0FBb0I7QUFDbEUsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsdURBQVM7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0EsMEVBQTBFLHVEQUFTO0FBQ25GO0FBQ0E7QUFDQSwwQkFBMEIsWUFBWTtBQUN0QyxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCwwQkFBMEI7QUFDckY7QUFDQSwwRUFBMEUsdURBQVM7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwwQkFBMEIsWUFBWTtBQUN0QyxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhLCtCQUErQixVQUFVO0FBQ3REO0FBQ0E7QUFDQSxpQkFBaUIsR0FBRyxJQUFJO0FBQ3hCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSwwQkFBMEIsWUFBWTtBQUN0QyxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhLCtCQUErQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYSxJQUFJO0FBQ2pCLFNBQVM7QUFDVCxLQUFLO0FBQ0wsQ0FBQyxFQUFFO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kdW9saW5nby1jbG9uZS8uL25vZGVfbW9kdWxlcy9yYS1kYXRhLXNpbXBsZS1yZXN0L2Rpc3QvZXNtL2luZGV4LmpzP2MxNDUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmltcG9ydCB7IHN0cmluZ2lmeSB9IGZyb20gJ3F1ZXJ5LXN0cmluZyc7XG5pbXBvcnQgeyBmZXRjaFV0aWxzIH0gZnJvbSAncmEtY29yZSc7XG4vKipcbiAqIE1hcHMgcmVhY3QtYWRtaW4gcXVlcmllcyB0byBhIHNpbXBsZSBSRVNUIEFQSVxuICpcbiAqIFRoaXMgUkVTVCBkaWFsZWN0IGlzIHNpbWlsYXIgdG8gdGhlIG9uZSBvZiBGYWtlUmVzdFxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21hcm1lbGFiL0Zha2VSZXN0XG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBnZXRMaXN0ICAgICA9PiBHRVQgaHR0cDovL215LmFwaS51cmwvcG9zdHM/c29ydD1bJ3RpdGxlJywnQVNDJ10mcmFuZ2U9WzAsIDI0XVxuICogZ2V0T25lICAgICAgPT4gR0VUIGh0dHA6Ly9teS5hcGkudXJsL3Bvc3RzLzEyM1xuICogZ2V0TWFueSAgICAgPT4gR0VUIGh0dHA6Ly9teS5hcGkudXJsL3Bvc3RzP2ZpbHRlcj17aWQ6WzEyMyw0NTYsNzg5XX1cbiAqIHVwZGF0ZSAgICAgID0+IFBVVCBodHRwOi8vbXkuYXBpLnVybC9wb3N0cy8xMjNcbiAqIGNyZWF0ZSAgICAgID0+IFBPU1QgaHR0cDovL215LmFwaS51cmwvcG9zdHNcbiAqIGRlbGV0ZSAgICAgID0+IERFTEVURSBodHRwOi8vbXkuYXBpLnVybC9wb3N0cy8xMjNcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuICogaW1wb3J0IHsgQWRtaW4sIFJlc291cmNlIH0gZnJvbSAncmVhY3QtYWRtaW4nO1xuICogaW1wb3J0IHNpbXBsZVJlc3RQcm92aWRlciBmcm9tICdyYS1kYXRhLXNpbXBsZS1yZXN0JztcbiAqXG4gKiBpbXBvcnQgeyBQb3N0TGlzdCB9IGZyb20gJy4vcG9zdHMnO1xuICpcbiAqIGNvbnN0IEFwcCA9ICgpID0+IChcbiAqICAgICA8QWRtaW4gZGF0YVByb3ZpZGVyPXtzaW1wbGVSZXN0UHJvdmlkZXIoJ2h0dHA6Ly9wYXRoLnRvLm15LmFwaS8nKX0+XG4gKiAgICAgICAgIDxSZXNvdXJjZSBuYW1lPVwicG9zdHNcIiBsaXN0PXtQb3N0TGlzdH0gLz5cbiAqICAgICA8L0FkbWluPlxuICogKTtcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBBcHA7XG4gKi9cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiAoYXBpVXJsLCBodHRwQ2xpZW50LCBjb3VudEhlYWRlcikge1xuICAgIGlmIChodHRwQ2xpZW50ID09PSB2b2lkIDApIHsgaHR0cENsaWVudCA9IGZldGNoVXRpbHMuZmV0Y2hKc29uOyB9XG4gICAgaWYgKGNvdW50SGVhZGVyID09PSB2b2lkIDApIHsgY291bnRIZWFkZXIgPSAnQ29udGVudC1SYW5nZSc7IH1cbiAgICByZXR1cm4gKHtcbiAgICAgICAgZ2V0TGlzdDogZnVuY3Rpb24gKHJlc291cmNlLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHBhcmFtcy5wYWdpbmF0aW9uLCBwYWdlID0gX2EucGFnZSwgcGVyUGFnZSA9IF9hLnBlclBhZ2U7XG4gICAgICAgICAgICB2YXIgX2IgPSBwYXJhbXMuc29ydCwgZmllbGQgPSBfYi5maWVsZCwgb3JkZXIgPSBfYi5vcmRlcjtcbiAgICAgICAgICAgIHZhciByYW5nZVN0YXJ0ID0gKHBhZ2UgLSAxKSAqIHBlclBhZ2U7XG4gICAgICAgICAgICB2YXIgcmFuZ2VFbmQgPSBwYWdlICogcGVyUGFnZSAtIDE7XG4gICAgICAgICAgICB2YXIgcXVlcnkgPSB7XG4gICAgICAgICAgICAgICAgc29ydDogSlNPTi5zdHJpbmdpZnkoW2ZpZWxkLCBvcmRlcl0pLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBKU09OLnN0cmluZ2lmeShbcmFuZ2VTdGFydCwgcmFuZ2VFbmRdKSxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IEpTT04uc3RyaW5naWZ5KHBhcmFtcy5maWx0ZXIpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB1cmwgPSBcIlwiLmNvbmNhdChhcGlVcmwsIFwiL1wiKS5jb25jYXQocmVzb3VyY2UsIFwiP1wiKS5jb25jYXQoc3RyaW5naWZ5KHF1ZXJ5KSk7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGNvdW50SGVhZGVyID09PSAnQ29udGVudC1SYW5nZSdcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hyb21lIGRvZXNuJ3QgcmV0dXJuIGBDb250ZW50LVJhbmdlYCBoZWFkZXIgaWYgbm8gYFJhbmdlYCBpcyBwcm92aWRlZCBpbiB0aGUgcmVxdWVzdC5cbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgUmFuZ2U6IFwiXCIuY29uY2F0KHJlc291cmNlLCBcIj1cIikuY29uY2F0KHJhbmdlU3RhcnQsIFwiLVwiKS5jb25jYXQocmFuZ2VFbmQpLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgICAgIHJldHVybiBodHRwQ2xpZW50KHVybCwgb3B0aW9ucykudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVycyA9IF9hLmhlYWRlcnMsIGpzb24gPSBfYS5qc29uO1xuICAgICAgICAgICAgICAgIGlmICghaGVhZGVycy5oYXMoY291bnRIZWFkZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBcIi5jb25jYXQoY291bnRIZWFkZXIsIFwiIGhlYWRlciBpcyBtaXNzaW5nIGluIHRoZSBIVFRQIFJlc3BvbnNlLiBUaGUgc2ltcGxlIFJFU1QgZGF0YSBwcm92aWRlciBleHBlY3RzIHJlc3BvbnNlcyBmb3IgbGlzdHMgb2YgcmVzb3VyY2VzIHRvIGNvbnRhaW4gdGhpcyBoZWFkZXIgd2l0aCB0aGUgdG90YWwgbnVtYmVyIG9mIHJlc3VsdHMgdG8gYnVpbGQgdGhlIHBhZ2luYXRpb24uIElmIHlvdSBhcmUgdXNpbmcgQ09SUywgZGlkIHlvdSBkZWNsYXJlIFwiKS5jb25jYXQoY291bnRIZWFkZXIsIFwiIGluIHRoZSBBY2Nlc3MtQ29udHJvbC1FeHBvc2UtSGVhZGVycyBoZWFkZXI/XCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YToganNvbixcbiAgICAgICAgICAgICAgICAgICAgdG90YWw6IGNvdW50SGVhZGVyID09PSAnQ29udGVudC1SYW5nZSdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcGFyc2VJbnQoaGVhZGVycy5nZXQoJ2NvbnRlbnQtcmFuZ2UnKS5zcGxpdCgnLycpLnBvcCgpLCAxMClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcGFyc2VJbnQoaGVhZGVycy5nZXQoY291bnRIZWFkZXIudG9Mb3dlckNhc2UoKSkpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0T25lOiBmdW5jdGlvbiAocmVzb3VyY2UsIHBhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuIGh0dHBDbGllbnQoXCJcIi5jb25jYXQoYXBpVXJsLCBcIi9cIikuY29uY2F0KHJlc291cmNlLCBcIi9cIikuY29uY2F0KHBhcmFtcy5pZCkpLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIGpzb24gPSBfYS5qc29uO1xuICAgICAgICAgICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBqc29uLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldE1hbnk6IGZ1bmN0aW9uIChyZXNvdXJjZSwgcGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgcXVlcnkgPSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyOiBKU09OLnN0cmluZ2lmeSh7IGlkOiBwYXJhbXMuaWRzIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB1cmwgPSBcIlwiLmNvbmNhdChhcGlVcmwsIFwiL1wiKS5jb25jYXQocmVzb3VyY2UsIFwiP1wiKS5jb25jYXQoc3RyaW5naWZ5KHF1ZXJ5KSk7XG4gICAgICAgICAgICByZXR1cm4gaHR0cENsaWVudCh1cmwpLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIGpzb24gPSBfYS5qc29uO1xuICAgICAgICAgICAgICAgIHJldHVybiAoeyBkYXRhOiBqc29uIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldE1hbnlSZWZlcmVuY2U6IGZ1bmN0aW9uIChyZXNvdXJjZSwgcGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgX2IgPSBwYXJhbXMucGFnaW5hdGlvbiwgcGFnZSA9IF9iLnBhZ2UsIHBlclBhZ2UgPSBfYi5wZXJQYWdlO1xuICAgICAgICAgICAgdmFyIF9jID0gcGFyYW1zLnNvcnQsIGZpZWxkID0gX2MuZmllbGQsIG9yZGVyID0gX2Mub3JkZXI7XG4gICAgICAgICAgICB2YXIgcmFuZ2VTdGFydCA9IChwYWdlIC0gMSkgKiBwZXJQYWdlO1xuICAgICAgICAgICAgdmFyIHJhbmdlRW5kID0gcGFnZSAqIHBlclBhZ2UgLSAxO1xuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0ge1xuICAgICAgICAgICAgICAgIHNvcnQ6IEpTT04uc3RyaW5naWZ5KFtmaWVsZCwgb3JkZXJdKSxcbiAgICAgICAgICAgICAgICByYW5nZTogSlNPTi5zdHJpbmdpZnkoWyhwYWdlIC0gMSkgKiBwZXJQYWdlLCBwYWdlICogcGVyUGFnZSAtIDFdKSxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IEpTT04uc3RyaW5naWZ5KF9fYXNzaWduKF9fYXNzaWduKHt9LCBwYXJhbXMuZmlsdGVyKSwgKF9hID0ge30sIF9hW3BhcmFtcy50YXJnZXRdID0gcGFyYW1zLmlkLCBfYSkpKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdXJsID0gXCJcIi5jb25jYXQoYXBpVXJsLCBcIi9cIikuY29uY2F0KHJlc291cmNlLCBcIj9cIikuY29uY2F0KHN0cmluZ2lmeShxdWVyeSkpO1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBjb3VudEhlYWRlciA9PT0gJ0NvbnRlbnQtUmFuZ2UnXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENocm9tZSBkb2Vzbid0IHJldHVybiBgQ29udGVudC1SYW5nZWAgaGVhZGVyIGlmIG5vIGBSYW5nZWAgaXMgcHJvdmlkZWQgaW4gdGhlIHJlcXVlc3QuXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJhbmdlOiBcIlwiLmNvbmNhdChyZXNvdXJjZSwgXCI9XCIpLmNvbmNhdChyYW5nZVN0YXJ0LCBcIi1cIikuY29uY2F0KHJhbmdlRW5kKSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge307XG4gICAgICAgICAgICByZXR1cm4gaHR0cENsaWVudCh1cmwsIG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSBfYS5oZWFkZXJzLCBqc29uID0gX2EuanNvbjtcbiAgICAgICAgICAgICAgICBpZiAoIWhlYWRlcnMuaGFzKGNvdW50SGVhZGVyKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgXCIuY29uY2F0KGNvdW50SGVhZGVyLCBcIiBoZWFkZXIgaXMgbWlzc2luZyBpbiB0aGUgSFRUUCBSZXNwb25zZS4gVGhlIHNpbXBsZSBSRVNUIGRhdGEgcHJvdmlkZXIgZXhwZWN0cyByZXNwb25zZXMgZm9yIGxpc3RzIG9mIHJlc291cmNlcyB0byBjb250YWluIHRoaXMgaGVhZGVyIHdpdGggdGhlIHRvdGFsIG51bWJlciBvZiByZXN1bHRzIHRvIGJ1aWxkIHRoZSBwYWdpbmF0aW9uLiBJZiB5b3UgYXJlIHVzaW5nIENPUlMsIGRpZCB5b3UgZGVjbGFyZSBcIikuY29uY2F0KGNvdW50SGVhZGVyLCBcIiBpbiB0aGUgQWNjZXNzLUNvbnRyb2wtRXhwb3NlLUhlYWRlcnMgaGVhZGVyP1wiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGpzb24sXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsOiBjb3VudEhlYWRlciA9PT0gJ0NvbnRlbnQtUmFuZ2UnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHBhcnNlSW50KGhlYWRlcnMuZ2V0KCdjb250ZW50LXJhbmdlJykuc3BsaXQoJy8nKS5wb3AoKSwgMTApXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHBhcnNlSW50KGhlYWRlcnMuZ2V0KGNvdW50SGVhZGVyLnRvTG93ZXJDYXNlKCkpKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKHJlc291cmNlLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIHJldHVybiBodHRwQ2xpZW50KFwiXCIuY29uY2F0KGFwaVVybCwgXCIvXCIpLmNvbmNhdChyZXNvdXJjZSwgXCIvXCIpLmNvbmNhdChwYXJhbXMuaWQpLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXJhbXMuZGF0YSksXG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBqc29uID0gX2EuanNvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHsgZGF0YToganNvbiB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvLyBzaW1wbGUtcmVzdCBkb2Vzbid0IGhhbmRsZSBwcm92aWRlIGFuIHVwZGF0ZU1hbnkgcm91dGUsIHNvIHdlIGZhbGxiYWNrIHRvIGNhbGxpbmcgdXBkYXRlIG4gdGltZXMgaW5zdGVhZFxuICAgICAgICB1cGRhdGVNYW55OiBmdW5jdGlvbiAocmVzb3VyY2UsIHBhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHBhcmFtcy5pZHMubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwQ2xpZW50KFwiXCIuY29uY2F0KGFwaVVybCwgXCIvXCIpLmNvbmNhdChyZXNvdXJjZSwgXCIvXCIpLmNvbmNhdChpZCksIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGFyYW1zLmRhdGEpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlcykgeyByZXR1cm4gKHsgZGF0YTogcmVzcG9uc2VzLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGpzb24gPSBfYS5qc29uO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ganNvbi5pZDtcbiAgICAgICAgICAgICAgICB9KSB9KTsgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKHJlc291cmNlLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIHJldHVybiBodHRwQ2xpZW50KFwiXCIuY29uY2F0KGFwaVVybCwgXCIvXCIpLmNvbmNhdChyZXNvdXJjZSksIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXJhbXMuZGF0YSksXG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBqc29uID0gX2EuanNvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHsgZGF0YToganNvbiB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWxldGU6IGZ1bmN0aW9uIChyZXNvdXJjZSwgcGFyYW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gaHR0cENsaWVudChcIlwiLmNvbmNhdChhcGlVcmwsIFwiL1wiKS5jb25jYXQocmVzb3VyY2UsIFwiL1wiKS5jb25jYXQocGFyYW1zLmlkKSwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoe1xuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ3RleHQvcGxhaW4nLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIganNvbiA9IF9hLmpzb247XG4gICAgICAgICAgICAgICAgcmV0dXJuICh7IGRhdGE6IGpzb24gfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gc2ltcGxlLXJlc3QgZG9lc24ndCBoYW5kbGUgZmlsdGVycyBvbiBERUxFVEUgcm91dGUsIHNvIHdlIGZhbGxiYWNrIHRvIGNhbGxpbmcgREVMRVRFIG4gdGltZXMgaW5zdGVhZFxuICAgICAgICBkZWxldGVNYW55OiBmdW5jdGlvbiAocmVzb3VyY2UsIHBhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHBhcmFtcy5pZHMubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwQ2xpZW50KFwiXCIuY29uY2F0KGFwaVVybCwgXCIvXCIpLmNvbmNhdChyZXNvdXJjZSwgXCIvXCIpLmNvbmNhdChpZCksIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L3BsYWluJyxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2VzKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgICAgIGRhdGE6IHJlc3BvbnNlcy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBqc29uID0gX2EuanNvbjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpzb24uaWQ7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTsgfSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ra-data-simple-rest/dist/esm/index.js\n");

/***/ })

};
;